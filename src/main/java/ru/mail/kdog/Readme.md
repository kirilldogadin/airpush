О проекте:
Минусы:
 
- примитивная иерарихия и орагнизация кода, за исключением разве что классов ServiceHandler и HttpClientTemplate.
Как исправить - создать базовые классы/интерфейсы для сервера/клиента, и прочее для рядовых операций. В целом в обработчиках я бы создал прослойку из "callback" чтобы получить АПИ похожий на нечто вроде Reactor Netty
Также я бы отделил бизнес логику от абстракций нетти(хендлеров). Бизнес-апи в идеале не должен содержать подробностей о нетти.

- архитектура синхронных/блокирующих операций в хенделере

- примитивное логирование - т.к. нетти подразумевает нагрузки, это явно станет узким место, синхронная отправка логов не имеет особого смысла, и отправка на диск тем более. 
Как исправить - 1 Может быть использован supplier (log4j2 его поддерживает) , 2. Вывод перенаправлен куда-то по сети, например в очереди(так точно будет сохранен порядок логов, что очень важно) 3. Старые добрые флаги уровня логирования захардкоженные код, но это конечно так-себе
А также можно копить логи и отправлять их уже Batch, т.к. сеть тоже не "резиновая"

- блокирующие операции в хендлере ServiceHandler - не совсем минус но все же, все-таки бизнес-хендлер запускается в отдельное group, что является рекоммендаций из самих оф источников нетти. Но все зависит от нашей логики,
 Как исправить - можно было бы передавать в очередь на обработку куда-то ещё, если логика более сложная. Главное разделить группы/пулы потоков асинхронного нети и блокирующих операций, если они есть.

- прерывание клиента/сервера - на данный реализовано через стандартный механизм ThreadInterruption, что не совсем "тру" при работе с нетти, обрабатывать такой механизм не все могут "правильно". Но сейчас можно прервать через kill -3. То есть присутсвует softShutdown и это будет корректное Gracefully завершение. Также должно быть "Hard" завершение, по таймеру, когда не надо ждать мягкого завершения.
Как исправить - я бы сделал очередь событий, в которой 2 типа событий, отправить сообщение по таймеру или прервать работу. А событие о прерывании работе можно слушать со стандартного ввода, как минимум ну или по другим различным апи, если нам вообще нужен клиент который постоянно что-то отправляет и нужно им управлять.
Очередь должна быть неблокирующий или , если она блокирующая, то должно быть отделено от основного пула нетти

- использование Unpooled  buffers. Использовать Pool. В зависимости от логики DirectBuffers



О сборке:
- один проект. 
Как исправить - Должно быть 2 модуля client, Server. ТАкже модуль Commons в котором находится proto зависимости, и который включается в оба проекта


Как и что следует тестировать перед введеним в эксплуатацию: 

1. Кол-во потоко в MainGroup и WorkerGroup
2. Отношение кол-ва потоков в MainGroup и WorkerGroup друг к другу, например 4/1, etc
3. Запросы с  keep-alive и без, т.к. у нас Http, то клиент не всегда может быть keep-alive
4. Тестирование с "dummy" логированием, т.е. в файл, а также в сеть, с разными уровнями, посмотреть разницу
5. Тестирование с HttpCompressor и без
6. Тестирование с "disabled" клиентами, (которые отправили запрос и отвалились)
7. Сравнить производительност реализации с архитектурой 1 когда наша блок логика в отдельном group но в хендлере с 2 когда логика в передается через черезь в другое место
8. Cравнить с ипользование Unpooled  buffers и Pool. 
9. Различные GC / различные настройки Gc, особенно отношение поколений и кол-во потоков сборщика
10. Тесты на java 11. Заведется ли вообще какой прирост и есть ли он


Мониторинг:

? - как идея, внудрение груви/бина консоли для динамического изменения, подтягинваия зависимостей и вообще любого изменения в рантайме, без перезапуска

Метрики:
Для запросов любые популярные фреймворки для снятия метрик

Ресурсы железа:
Здесть будет большая разница для использования при тестировании и на продакшене
В тестировании мы вольны использовать любые средства мониторинга и снятия дампов
Для продакшена я бы рекомендовал отсылать статистику выдаваемую Linux utils, можно поэксперементировать с какими-нибудь опен фрейфмворками - Stagemonitor,  Kamon, etc - НО неясно насколько они примениемы в highload 
